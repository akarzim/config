/**
 * Rpc - A jquery plugin for remote procedure calls between iframes in a
 * javascript / HTML application.
 * 
 * This allows one to very conveniently make function calls between iframes, 
 * using the window.postMessage facility for safe, secure inter-iframe messaging.
 * 
 * Once the Rpc channels are set up, the caller makes what looks like, and is, 
 * an ordinary function call, passing whatever arguments it wishes*, and 
 * receiving a jQuery promise as the returned value.
 * 
 * The arguments are marshalled to the other iframe, the target function is
 * called, and any returned value is marshalled back, and used to resolve the
 * promise. Errors in the call, like a missing function or an exception, will
 * reject the promise with an rpc.error object.
 * 
 * If the target function itself returns a promise, listeners are attached to 
 * the resolve, reject, and notify methods, and the promise is transparently
 * proxied back to the caller's iframe.
 * 
 * *Arguments must be suitable for JSON.stringify().
 * 
 * Install by loading the script after jquery.
 * 
 * To use:
 * - Create an RPC initialization parameters object.
 * - Open an RPC channel by:
 *    $.rpc(params);
 * 
 * Opening the channel sets up one half of the communication.  It prepares the
 * local side to send messages to and receive responses from the remote side.
 * A parameter to the openChannel call specifies all of the properties
 * of the channel:
 *   channelId: {String} a name by which the two sides know the channel.  Needed
 *     if any iframe opens more than one channel.  A single "anonymous" channel
 *     can also be defined.
 *   remoteDomain: {String} The domain name from which responses will be accepted.
 *   target: {DOMElement} The iframe or window to which messages will be posted.
 *   name: {String} For application's use.  Useful for debugging, but not used.
 *   local: {Object} An object implementing any functions that will be available
 *     to the other side.
 *   iRemote: {Object} An object that describes the functions that are expected
 *     on the other side.  Used to create a proxy object representing the 
 *     other side.  The proxy object will contain a function for every property
 *     of iRemote that:
 *     - is a function.  The generated function will dispatch the remote function
 *       call, but will return no value.
 *     - has a property 'options' with a property 'rpc' that evaluates to true.
 *       The functions generated for these will return a promise that will be
 *       resolved/rejected/notified with the corresponding results from the
 *       remote function.
 *     NOTE: the iRemote object *describes* the proxy.  The proxy is created
 *       by jquery-rpc, and does not include the iRemote.
 *   
 * 
 */


(function($){
    
    var channels = {},
        anonymousChannel;
    
    function RpcChannel(params /*channelId, remoteDomain, target, iRemote, local*/) {
        var channel = params;
        // A list of calls that are awaiting a response from the remote side.
        channel.awaitingResponse = {nextId: 1};
        // Promise returned from function calls; we wait on resolve/reject/notify
        //  and forward back to the calling side.
        channel.promisedResponse = {};


        ///////////////////////////////////////////////////////////////////////////
        //
        // Start of 'Remote Side' code.  Processes a received message, and calls
        //  the appropriate function in local.  If the caller wanted a response,
        //  captures the returned value from the local function call, and returns
        //  that to the calling side (if the returned value is a promise, it is
        //  more complicated: we wait for the promise to resolve/reject/notify, and
        //  return that to the other side).
        //

        function waitForPromise(id, promise) {
            var resp = channel.promisedResponse[id] = {
                id:id, 
                promise:promise,
                onDone: function() {
                    postResponse(makeResponse(id, 'resolve', arguments));
                    delete channel.promisedResponse[id];
                },
                onFail: function() {
                    postResponse(makeResponse(id, 'reject', arguments));
                    delete channel.promisedResponse[id];
                },
                onNotify: function() {
                    postResponse(makeResponse(id, 'notify', arguments));
                }
            };
            promise.then(resp.onDone, resp.onFail, resp.onNotify);
        } // End of waitForPromise

        function postResponse(response) {
            if (response && response.id) {
                var msg = {'response': response};
                if (channel.channelId) {
                    msg['channelId'] = channel.channelId;
                }
                channel.target.postMessage(msg, "*");
            }
        }
        /**
         * Builds a response object, to return to the calling side.
         * @param {Number} id The response id sent from the calling side.
         * @param {String} action One of 'resolve', 'reject', or 'notify', which is the
         *   method to be called on the promise on the calling side.
         * @param {Array.<object>} args An array of arguments to be applied to the action
         *   method on the calling side.
         * @return {Object} An object suitable for postMessage.
         */
        function makeResponse(id, action, args) {
            return {'id':id, 'action':action, 'args':JSON.stringify(jQuery.makeArray(args))};
        }

        function doCallMethod(message) {
            var method = message.data.method;
            var responseId = message.data.responseId;
            var result, response;
            console.log('call for ' + method + ', id: ' + responseId);


            // Only try to call things that are actually functions.
            if (channel.local[method] && (typeof channel.local[method] === 'function') ) {
                if (!channel.target) {
                    channel.target = message.source;
                }
                try {
                    if (message.data.param) {
                        // param => single parameter, passed directly
                        result = channel.local[method](message.data.param);
                    } else if (message.data.args) {
                        // args => 'arguments', passed as an array
                        result = channel.local[method].apply(channel.local, JSON.parse(message.data.args));
                    } else {
                        //  => no parameters.
                        result = channel.local[method]();
                    }
                    // If the result is a promise, wrap it so we can eventually reply with result
                    if (result && jQuery.isFunction(result.promise)) {
                        waitForPromise(responseId, result);
                    } else {
                        // Not a promise; just return the result.
                        response = makeResponse(responseId, 'resolve', [result]);
                    }
                } catch (ex) {
                    response = makeResponse(responseId, 'reject', [new rpc.error("Exception thrown by target method.", ex)]);
                }
            } else {
                // Not a function; return the appropriate error.
                response = makeResponse(responseId, 'reject', [new rpc.error("Target has no such method.", method)]);
            }

            postResponse(response);
        } // End of doCallMethod

        //
        // End of 'Remote Side' code. 
        //
        ///////////////////////////////////////////////////////////////////////////

        ///////////////////////////////////////////////////////////////////////////
        //
        // Start of 'Local Side' code.  When call is made on a proxy for a remote
        //  function, this packages the arguments and sends it across.  If a response
        //  is desired, returns a promise back to the caller.  The promise will be
        //  resolved/rejected/notified based on future messages received from the
        //  remote side.
        //

        function doAwaitedResponse(message) {
            var id = message.data.response.id;
            if (!channel.awaitingResponse[id]) {
                return;
            }
            var dfd = channel.awaitingResponse[id].dfd, 
                args = JSON.parse(message.data.response.args),
                action = message.data.response.action;
            console.log('response: ' + id);
            if (jQuery.isFunction(dfd[action])) {
                dfd[action].apply(dfd, args);
            }
        } // End of doAwaitedResponse

        /**
        * Saves the context needed to wait for a result from the remote side, and 
        * a timer that will fire if the remote side does not respond in a timely
        * manner.
        * @param {Number} timeout How long to wait for a response.
        * @return {Object} A context object.
        */
        function makeWaiter(functionName, timeout) {
            function onTimeout() {
                console.log('timeout waiting for response from: '+functionName);
                waiter.timeout = null;
                waiter.dfd.reject(new rpc.error('timeout'));
            }
            function onFinished() {
                if (waiter.timeout) {
                    clearTimeout(waiter.timeout);
                    waiter.timeout = null;
                }
                waiter.dfd = null;
                delete channel.awaitingResponse[waiter.id];
            }
            function onNotify() {
                // Extend the timeout.
                if (timeout && waiter.timeout) {
                    clearTimeout(waiter.timeout);
                    waiter.timeout = setTimeout(onTimeout, timeout);
                }
            }
            var id = channel.awaitingResponse.nextId++;
            var waiter = {
                'id': id, 
                'dfd': new jQuery.Deferred()
            };
            if (timeout && timeout > 0) {
                waiter.timeout = setTimeout(onTimeout, timeout);
            }
            waiter.dfd.then(onFinished, onFinished, onNotify);
            channel.awaitingResponse[id] = waiter;
            return waiter;
        } // End of makeWaiter

        /**
         * Called by the generated proxy function to send a function call to the remote side.
         * @param {String} functionName The name of the function to be called on the remote side.
         * @param {Options} options Currently only 'timeout' is supported.  If non-zero, a
         *   waiter will be created to listen for responses from the remote.
         * @param {Array.<object>} args An array of arguments to pass to the remote function.
         * @return {Promise|undefined} Returns a promise if a result is expected, or nothing
         *   otherwise.
         *   
         * Creates an object:
         * {
         *    method: functionName  // Name of function to call on remote side.
         *    args: [...]           // An array of zero or more arguments to be passed to function.
         *    responseId: number    // If present, an id by which to associate returned results.
         * }
         * 
         */
        channel.invokeRemote = function(functionName, options, args) {
            var postArgs, waiter;
            postArgs = {'method': functionName, 'args': JSON.stringify(jQuery.makeArray(args))};
            if (channel.channelId) {
                postArgs['channelId'] = channel.channelId;
            }
            if (options.timeout) {
                waiter = makeWaiter(functionName, options.timeout);
                postArgs['responseId'] = waiter.id;
            }
            console.log('calling remote method: ' + functionName + ', id: ' + postArgs.responseId);
            channel.target.postMessage(postArgs, "*");
            return waiter && waiter.dfd.promise();
        };

        //
        // End of 'Local Side' code.
        //
        ///////////////////////////////////////////////////////////////////////////

        /**
        * Called to process a message received from a postMessage in another window.
        * The message may be a call or a response to a call; dispatch appropriately.
        * @param {Object} message The message from another window.
        */
        channel.receiveMessage = function(message) {
            // console.log('Received message from '+message.origin+': '+JSON.stringify(message.data));
            if (channel.remoteDomain !== "*" && !message.origin.match(channel.remoteDomain)) {
                return;
            }
            if (message.data.method) {
                doCallMethod(message);
            } else if (message.data.response) {
                doAwaitedResponse(message);
            }
        };

        /*
        * Creates a proxy object with functions for all of the functions in
        * iRemote.  These functions will forward their arguments to
        * the corresponding remote function; if configured to return
        * a result, they return a promise on the eventual result from
        * the remote side.
        */
        function makeRemoteProxy(channel, iRemote) {
            function makeProxyFunction(functionName, options) {
                return function() {
                    return channel.invokeRemote(functionName, options, arguments);
                };
            }

            var options, proxyObject = {'__channel__': channel};

            // The namespace of this object really belongs to the caller.  Don't pollute it.
            for (var fn in iRemote) {
                // console.log(fn);
                if (iRemote.hasOwnProperty(fn)) {
                    if (iRemote[fn].options && iRemote[fn].options.rpc) {
                        options = (iRemote[fn].options) ? iRemote[fn].options : {};
                        // RpcFunctions have to have *some* timeout, even if -1, meaning "forever".
                        options.timeout = options.timeout || channel.timeout;
                    } else if (typeof iRemote[fn] === "function") {
                        options = (iRemote[fn].options) ? iRemote[fn].options : {};
                    }
                    proxyObject[fn] = makeProxyFunction(fn, options);
                }
            }
            return proxyObject;
        } // End of RemoteProxy

        /**
        * Closes the channel.  It will no longer receive nor be able to send messages.
        */
        channel.close = function() {
            channel.invokeRemote = function(){
                throw new rpc.error('Channel is closed');
            };
            channel.receiveMessage = function(){};
            channel.remoteProxy = undefined;
        };

        channel.proxyObject = makeRemoteProxy(channel, channel.iRemote);

        return channel;
    } // End of RpcChannel

    /**
     * Called to process a message received from a postMessage in another window.
     * The message may be a call or a response to a call; dispatch appropriately.
     * @param {Object} message The message from another window.
     */
    function receiveMessage(message) {
        // Dispatch to the proper channel.
        var channel = message.data.channelId;
        if (channel && channels[channel]) {
            channels[channel].receiveMessage(message);
        } else if (!channel && anonymousChannel) {
            anonymousChannel.receiveMessage(message);
        } else {
            console.log('RPC: received message for unknown channel: '+channel);
        }
    }
    
    function rpc(params) {
        params = $.extend({}, rpc.defaults, params);
        var channelId = params.channelId;
        if (channelId && channels[params.channelId]) {
            throw new rpc.error('Channel already opened', params.channelId);
        } else if (!channelId && anonymousChannel) {
            throw new rpc.error('Anonymous channel already opened');
        }
        var channel = RpcChannel(params);
        if (channelId) {
            channels[params.channelId] = channel;
        } else {
            anonymousChannel = channel;
        }

        return channel.proxyObject;
    }
    rpc.defaults = {timeout: 30000};
    
    rpc.close = function(params) {
        var channelId = (typeof params === 'string') ? params : params.channelId;
        if (channelId && channels[channelId]) {
            channels[channelId].close();
            delete channels[channelId];
        } else if (!channelId && anonymousChannel) {
            anonymousChannel.close();
            anonymousChannel = undefined;
        }
    };
    
    // Define rpc.error
    rpc.error = function(message, data) {
        this.name = "rpc.error";
        this.message = message;
        this.data = data;
    };
    rpc.error.prototype = new Error();
    rpc.error.prototype.constructor = rpc.error;

    // Define rpc.fn, for describing remote functions.
    rpc.fn = function(options) {
        if (!this instanceof rpc.fn) {
            return new rpc.fn(options);
        }
        this.options = $.extend({rpc:true}, options);
        return this;
    };

    // Establish RPC listener
    window.addEventListener("message", receiveMessage, false);
    
    // Install into jQuery
    $.rpc = rpc;

}(jQuery));

